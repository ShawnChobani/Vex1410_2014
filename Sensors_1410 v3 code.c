#pragma config(Sensor, in1,    armPotentiometerLeft, sensorPotentiometer)
#pragma config(Sensor, in2,    armPotentiometerRight, sensorPotentiometer)
#pragma config(Sensor, in3,    Gyro,           sensorNone)
#pragma config(Sensor, dgtl1,  EncoderFrontLeft, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  EncoderFrontRight, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  EncoderBackLeft, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  EncoderBackRight, sensorQuadEncoder)
#pragma config(Sensor, dgtl11, Jumper1,        sensorDigitalIn)
#pragma config(Sensor, dgtl12, Jumper2,        sensorDigitalIn)
#pragma config(Motor,  port1,           CrayonIntake,  tmotorVex393, openLoop)
#pragma config(Motor,  port2,           FrontLeft,     tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port3,           FrontRight,    tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port4,           BackRight,     tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port5,           BackLeft,      tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port6,           LeftLift1,     tmotorVex393, openLoop)
#pragma config(Motor,  port7,           LeftLift2,     tmotorVex393, openLoop)
#pragma config(Motor,  port8,           RightLift1,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           RightLift2,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port10,          CubeIntake,    tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

int gyrotestval;
int jumper1testval;
int jumper2testval;

int filterjoystick (int joystick);

int DefaultLeftValue = 0;
int DefaultRightValue = 0;

void ForBack (int power);
void LeftRight (int power);
void Rotate (int power);
void Claw (int power);
void Lift (int power);
int LiftAdjust (int thisP, int otherP);
int GetLeftPower(float leftPot, float rightPot);
int GetRightPower(float leftPot, float rightPot);
void GyroRotate(int angle);

int ReverseIfNeeded(int power);

float GetLeftValue();
float GetRightValue();
void AdjustLift();

bool MovingForward = true;

typedef enumWord {
    Adjusted = 0,
		Up = 1,
    Down = 2
} ACTIONS;

ACTIONS PreviousAction;

/////////////////////////////////////////////////////////////////////////////////////////
//																																										 //
//                          Pre-Autonomous Functions																	 //
//																																										 //
// You may want to perform some actions before the competition starts. Do them in the	 //
// following function.																																 //
//																																										 //
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  //bStopTasksBetweenModes = true;

	//Completely clear out any previous sensor readings by setting the port to "sensorNone"
 	SensorType[Gyro] = sensorNone;
 	wait1Msec(1000);
 	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
 	SensorType[Gyro] = sensorGyro;
 	wait1Msec(2000);

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

////////////////////////////////////////////////////////////////////////////////////////////////
//																																														//
//                                 Autonomous Task																						//
//																																														//
// This task is used to control your robot during the autonomous phase of a VEX Competition.	//
// You must modify the code to add your own robot specific commands here.											//
//																																														//
////////////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
		//static bool adjacent = false; //true if square next to drivers
		//if (adjacent)
			if (SensorValue[Jumper1] == 1)
			{
				motor[CubeIntake] = -50;
				wait1Msec (500);
				motor[CubeIntake] = 0;
				LeftRight (45); //The robot goes forward slightly to align accurately with the skyrise section
				wait1Msec (500); //update with sensor
				LeftRight (0);
				Claw (100); //Then, our claw will grab the section (NOTE: The power value will not be set to 0 in order for the claw to firmly grab the section)
				wait1Msec (1000);
				Lift (-90); //Lift our 	robot up
				wait1Msec (1500); //update with sensor
				Lift (0);
				//Rotate (44); //Rotate towards the base
				//wait1Msec (1000); //update with sensor
				//Rotate (0);
				GyroRotate(900);
				Lift (75); //Lower our lift
				wait1Msec (1500);
				Lift (0);
				Claw (-50);
				wait1Msec (500);
				Claw (0);
			}
			else
			{
				GyroRotate(900);
			}
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//																																														 //
//                                 User Control Task																					 //
//																																														 //
// This task is used to control your robot during the user control phase of a VEX Competition. //
// You must modify the code to add your own robot specific commands here.											 //
//																																														 //
/////////////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	bool Sclosed = true;
	bool Sopening = false;
	bool Sopen = false;
	bool Sclosing = false;

  const int power7 = 40;
	 //DefaultLeftValue = SensorValue[armPotentiometerLeft];
	 //DefaultRightValue = SensorValue[armPotentiometerRight];

	DefaultLeftValue = 1638;
	DefaultRightValue = 1628;


	/*
	int leftPot = SensorValue[armPotentiometerLeft];
	int rightPot = SensorValue[armPotentiometerRight] - 5;

	ClearTimer(T1);
*/

	while (true)
	{
	//	ClearTimer(T1);
		//while (time1[T1] < 50)
		//{

		//}

        // reverse when moving backward
        if (vexRT[Btn7U] == 1) MovingForward = true;
        else if(vexRT[Btn7D] == 1) MovingForward = false;


		int filtered2 = filterjoystick(vexRT[Ch2]); //forward and backwards
																								//left and right
		int filtered4 = filterjoystick(vexRT[Ch4]);	//rotate

		//leftPot = SensorValue[armPotentiometerLeft];
		//rightPot = SensorValue[armPotentiometerRight] - 5;

        // Button7
		// int filtered7u = filterjoystick(vexRT[Btn7U]);
		// int filtered7d = filterjoystick(vexRT[Btn7D]);

		// Button7
        filtered2 = ReverseIfNeeded(filtered2);
        // filtered4 = ReverseIfNeeded(filtered4);
        int power7r = ReverseIfNeeded(power7);

		//standard drive motor block
		motor[FrontLeft] = filtered2 + filtered4 + vexRT[Btn7R] * power7r - vexRT[Btn7L] * power7r;
		motor[FrontRight] = filtered2 - filtered4 - vexRT[Btn7R] * power7r + vexRT[Btn7L] * power7r;
		motor[BackRight] = filtered2 - filtered4 + vexRT[Btn7R]* power7r - vexRT[Btn7L] * power7r;
		motor[BackLeft] = filtered2 + filtered4 - vexRT[Btn7R] * power7r + vexRT[Btn7L] * power7r;

		gyrotestval = SensorValue[Gyro];
		jumper1testval = SensorValue[Jumper1];
		jumper2testval = SensorValue[Jumper2];

		if (vexRT[Btn5D] == 1) GyroRotate(450);

		// Button7
		// motor[LeftLift1] = (vexRT[Btn7D] - vexRT[Btn7U]) * 127 + vexRT[Btn8L] * 20 - vexRT[Btn8R] * 20;
		// motor[LeftLift2] = (vexRT[Btn7D] - vexRT[Btn7U]) * 127 + vexRT[Btn8L] * 20 - vexRT[Btn8R] * 20;
		// motor[RightLift1] = (vexRT[Btn7D] - vexRT[Btn7U]) * 127 + vexRT[Btn8R] * 20 - vexRT[Btn8L] * 20;
		// motor[RightLift2] = (vexRT[Btn7D] - vexRT[Btn7U]) * 127 + vexRT[Btn8R] * 20 - vexRT[Btn8L] * 20;


		//standard scissor lift block
		/*motor[LeftLift1] = vexRT[Ch2Xmtr2] + vexRT[Ch4Xmtr2];
		motor[LeftLift2] = vexRT[Ch2Xmtr2] + vexRT[Ch4Xmtr2];
		motor[RightLift1] = vexRT[Ch2Xmtr2] - vexRT[Ch4Xmtr2];
		motor[RightLift2] = vexRT[Ch2Xmtr2] - vexRT[Ch4Xmtr2];
		*/
		//testing scissor lift block DO NOT USE WITH ANY OTHER BLOCK

		float leftPot = GetLeftValue();
  	    float rightPot = GetRightValue();


		int lp = GetLeftPower(leftPot, rightPot);
		int rp = GetRightPower(leftPot, rightPot);

		if (lp != 0 && rp != 0)
		{
		    writeDebugStream("lp: %d	", lp);
		    writeDebugStreamLine("rp: %d", rp);
	    }

	  // lp = 127;
	  // rp = 127;

	  // int temp = lp;
	  // lp = rp;
	  // rp = temp;
		motor[LeftLift1] =  (vexRT[Btn8D] - vexRT[Btn8U]) * lp + vexRT[Btn8L] * 25 - vexRT[Btn8R] * 25;
		motor[LeftLift2] =  (vexRT[Btn8D] - vexRT[Btn8U]) * lp + vexRT[Btn8L] * 25 - vexRT[Btn8R] * 25;
		motor[RightLift1] = (vexRT[Btn8D] - vexRT[Btn8U]) * rp + vexRT[Btn8R] * 25 - vexRT[Btn8L] * 25;
		motor[RightLift2] = (vexRT[Btn8D] - vexRT[Btn8U]) * rp + vexRT[Btn8R] * 25 - vexRT[Btn8L] * 25;

        // adjust when we stops
		AdjustLift();

		motor[CubeIntake] = vexRT[Btn5U] * -127;

		/*if (vexRT[Btn5D] == 1)
		{
			static bool adjacent = false; //true if square next to drivers
			if (adjacent)
			{
				LeftRight (45); //The robot goes forward slightly to align accurately with the skyrise section
				wait1Msec (500);
				LeftRight (0);
				Claw (100); //Then, our claw will grab the section (NOTE: The power value will not be set to 0 in order for the claw to firmly grab the section)
				wait1Msec (1000);
				Lift (-90); //Lift our robot up
				wait1Msec (1500);
				Lift (0);
				Rotate (44); //Rotate towards the base
				wait1Msec (1000);
				Rotate (0);
				Lift (75); //Lower our lift
				wait1Msec (1500);
				Lift (0);
				Claw (-50);
				wait1Msec (500);
				Claw (0);
			}
			else
			{
				//routine 2 (the red side)
				LeftRight (-45); //The robot goes forward slightly to align accurately with the skyrise section
				wait1Msec (500);
				LeftRight (0);
				Claw (100); //Then, our claw will grab the section (NOTE: The power value will not be set to 0 in order for the claw to firmly grab the section)
				wait1Msec (1000);
				Lift (-90); //Lift our robot up
				wait1Msec (1500);
				Lift (0);
				Rotate (-44); //Rotate towards the base
				wait1Msec (1000);
				Rotate (0);
				Lift (75); //Lower our lift
				wait1Msec (1500);
				Lift (0);
				Claw (-50);
				wait1Msec (500);
				Claw (0);
			}
		}*/
		//This is the implementation of the state-based logic of the claw!
		//There are four possible states that our claw can be in: closed, open, closing, and opening.
		//Basically, we are telling the claw what it should be doing for each state.



		if (Sclosed) //This is when the claw is in the closed state
		{
			//If the open button is pressed, we want to go to the opening state
			//To do this, we must leave the closed state.
			//To leave the closed state, we have to set Sclosed to false!
			//To arrive at the opening state, we have to set Sopening to true!

			if (vexRT[Btn6U] == 1) //If we are pressing the open button
			{
				Sclosed = false; //Then we are leaving the closed state
				Sopening = true; //and entering the opening state!
			}
			else if (vexRT[Btn6D] == 1) //Otherwise, if we are pressing the close button
			{
				Sclosed = false; //Then we are leaving the closed state
				Sclosing = true; //and entering the closing state!
			}
			motor[CrayonIntake] = 0; //If the claw is closed, there is no need to use power in the motor
		}
		else if (Sopen) //This is when the claw is in the open state
		{
			if (vexRT[Btn6D] == 1) //If we are pressing the close button
			{
				Sopen = false;   //Then we are leaving the open state
				Sclosing = true; //and entering the closing state!
			}
			else if (vexRT[Btn6U] == 1) //On the other hand (claw), if we are pressing the open button
			{
				Sopen = false;   //Then we are leaving the open state
				Sopening = true; //and entering the opening state!
			}
			motor[CrayonIntake] = 20; //Although the claw is open, we need to apply a bit of power into the motor due to the elastics
		}
		else if (Sclosing) //This is when the claw is closing
		{
			if (vexRT[Btn6D] == 0) //If the close button isn't pressed...
			{
				Sclosing = false; //Then we are leaving the closing state
				Sclosed = true;   //and reaching for the closed state
			}
			motor[CrayonIntake] = -127; //While the claw is closing, we are going full speed in the negative direction
		}
		else if (Sopening) //This is when the claw is opening
		{
			if (vexRT[Btn6U] == 0) //If the open button isn't pressed...
			{
				Sopening = false; //Then we are leaving the opening state
				Sopen = true; //and are towards the open state!!!
			}
			motor[CrayonIntake] = 127; //While the claw is opening, we are going full speed in the positive direction
		}
	}
}

int ReverseIfNeeded(int power)
{
    return MovingForward ? power : -power;
}

int filterjoystick (int joystick)
{
	const int deadband = 5;
	const int minimumy = 5;
	const int inflectionx = 85;
	const int inflectiony = 45;

	if (joystick >= inflectionx)
	{
		//put on steep line segment on far right
		return ((127 - inflectiony) * (joystick - inflectionx) / (127 - inflectionx) + inflectiony);
	}
	else if (joystick > deadband)
	{
		//put on shallow line segment on close right
		return ((inflectiony - minimumy) * (joystick - deadband) / (inflectionx - deadband) + minimumy);
	}
	else if (joystick <= -inflectionx)
	{
		//put on steep line segment on far left
		return -(((127 - inflectiony) * (-joystick - inflectionx) / (127 - inflectionx) + inflectiony));
	}
	else if (joystick < -deadband)
	{
		//put on shallow line segment on close left
		return -(((inflectiony - minimumy) * (-joystick - deadband) / (inflectionx - deadband) + minimumy));
	}
	else
	{
		return 0; //it's in the deadband
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////
/// GetValues
/// Get Potentiometer values
/////////////////////////////////////////////////////////////////////////////////////////////
float GetLeftValue()
{
	int sValue = SensorValue[armPotentiometerLeft];
	float value = (sValue * 0.99) - DefaultLeftValue;
	if (value <0) value = 0;

		return value;
}

float GetRightValue()
{
		int sValue = SensorValue[armPotentiometerRight];
		float value =  sValue - DefaultRightValue;
		if (value <0) value = 0;

		return value;
}

/////////////////////////////////////////////////////////////////////////////////////////////
/// GetPowers
/// Calculate the power for lifts based on the sensor values and the current actions
/////////////////////////////////////////////////////////////////////////////////////////////
int GetLeftPower(float leftPot, float rightPot)
{
	const int fullPower = 127;
	const int fullPower_Down = 100;
	const float delta = 0.6;
	const float delta_Down = 0.36;

    // No buttons pressed
	if (vexRT[Btn8D] == 0 && vexRT[Btn8U] == 0) return 0;

    // On moving up
    if (vexRT[Btn8U] == 1)
	{
        // moving up
        PreviousAction = Up;

        // if we just started moving, we need full power.
		if (leftPot <= 500) return fullPower;

        // when the right lift is higher, we need full power for the left
		if (leftPot <= rightPot) return fullPower;
		else
		{
            // when the left is higher, we need to slow down the left
            // the delta is a magic number. we need even less power for left while the other one is catching up
			float offset = (rightPot / leftPot) * 100 * delta;
			int power = (fullPower * offset) / 100;
			return power;
		}
	}
    // On moving down
	else if (vexRT[Btn8D] == 1)
	{
        // moving down
        PreviousAction = Down;

        // if the current is higher than the other, need full power. but we still don't need 127.
		if (leftPot >= rightPot)
		{
			if (leftPot <= 400)
			{
				// need to slow down?;
			}
			return fullPower_Down;
		}
		else
		{
			float offset = (leftPot / rightPot) * delta_Down;
			int power = (fullPower_Down * offset);
			return power;
		}
	}

	return 0;
}

int GetRightPower(float leftPot, float rightPot)
{
	const int fullPower = 127;
	const int fullPower_Down = 100;
	const float delta = 0.6;
	const float delta_Down = 0.36;

	if (vexRT[Btn8D] == 0 && vexRT[Btn8U] == 0) return 0;

	if (vexRT[Btn8U] == 1)
	{
        PreviousAction = Up;
		if (rightPot <= 500) return fullPower;

		if (leftPot >= rightPot) return fullPower;
		else
		{
			float offset = (leftPot / rightPot) * 100 * delta;
			int power = (fullPower * offset) / 100;
			return power;
		}
	}
	else if (vexRT[Btn8D] == 1)
	{
        PreviousAction = Down;
		if (leftPot <= rightPot)
		{
			if (rightPot <= 400)
			{
                // need to slow down
			}
			return fullPower_Down;
		}
		else
		{
			float offset = (rightPot / leftPot) * delta_Down;
			int power = (fullPower_Down * offset);
			return power;
		}
	}

	return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////
/// Adjust lifts
/// Adjust the lifts whenever we release the buttons.
/////////////////////////////////////////////////////////////////////////////////////////////
void AdjustLift()
{
    // any buttons pressed? if so, returns;
	if (vexRT[Btn8D] != 0 || vexRT[Btn8U] != 0) return;

    // already adjusted? if so, returns;
	if (PreviousAction == Adjusted) return;

	motor[LeftLift1] = 0;
	motor[LeftLift2] = 0;

	motor[RightLift1] = 0;
	motor[RightLift2] = 0;

	float leftPot = GetLeftValue();
    float rightPot = GetRightValue();

    // skip adjustment, if the lifts are too low or too higt.
    if ((leftPot <= 200 && rightPot <=200) || (leftPot >= 1700 && rightPot >= 1700)) return;

    // offset = tolerance
    int offset = 10;
    int offset_Down = 5;

    // power values that we need for up and down
	int power = -33;
	int power_Down = -35; // adjust by moving up even for down. found it is more stable. use positive values to adjust by moving down.

    if (leftPot == rightPot) return;

    // in case of moving up
    if (PreviousAction == Up)
    {
		if (leftPot > rightPot)
		{
            // when the left is higher, move up the right until the right + offset is not lower than the left.
			while (leftPot > rightPot + offset)
			{
					motor[RightLift1] = motor[RightLift2] = power;

					leftPot = GetLeftValue();
			        rightPot = GetRightValue();
			}
		}
		else if (leftPot < rightPot)
		{
			while (leftPot + offset < rightPot)
			{
					motor[LeftLift1] = motor[LeftLift2] = power;

					leftPot = GetLeftValue();
    				rightPot = GetRightValue();
			}
		}
	}
	else if (PreviousAction == Down)
	{
        // ok, for down. even more interesting
        // let's wait for 1.3 secs. (until the lift completely stops)
	    ClearTimer(T1);
		while (time1[T1] < 1300){}

        leftPot = GetLeftValue();
        rightPot = GetRightValue();

		if (leftPot > rightPot)
		{
			while (leftPot  > rightPot + offset_Down)
			{

				motor[RightLift1] = motor[RightLift2] = power_Down;

                // uncommend the block below if we want to adjust by moving down.
                // then we might need the delays
                // motor[LeftLift1] = power_Down;
				// motor[LEftLift2] = power_Down;

				// ClearTimer(T1);
				// while (time1[T1] < 300){}

				leftPot = GetLeftValue();
				rightPot = GetRightValue();
			}
		}
		else if (leftPot < rightPot)
		{
			while (leftPot + offset_Down < rightPot)
			{

				motor[LeftLift1] = motor[LeftLift2] = power_Down;

                // uncommend the block below if we want to adjust by moving down.
				// motor[RightLift1] = power_Down;
				// motor[RightLift2] = power_Down;

				// ClearTimer(T1);
				// while (time1[T1] < 300){}

				leftPot = GetLeftValue();
				rightPot = GetRightValue();
			}
		}
	}

	motor[LeftLift1] = 0;
	motor[LeftLift2] = 0;
	motor[RightLift1] = 0;
	motor[RightLift2] = 0;

    // finish the adjustment
    PreviousAction = Adjusted;
}


int LiftAdjust (int thisP, int otherP)
{
	const int tolerance = 10;
	int scaletolerance = ((thisP + otherP) / 2 - 1550) / 200;
	if (thisP > otherP + (tolerance - scaletolerance))
	{
		return 1 + (1 * (thisP - otherP)) / 1;
	}
	else if (thisP + (tolerance - scaletolerance) < otherP)
	{
		return -1 + (1 * (thisP - otherP)) / 1;
	}
	else
	{
		return 0;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//
//                               Functions Below
//
//
/////////////////////////////////////////////////////////////////////////////////////////////
void ForBack(int power)
{
    motor[FrontLeft] = power;
    motor[FrontRight] = power;
    motor[BackRight] = power;
    motor[BackLeft] = power;
}

void LeftRight(int power)
{
	if (SensorValue[Jumper2] == 0)
	{
		power = -power;
	}
    motor[FrontLeft] = power;
    motor[FrontRight] = -power;
    motor[BackRight] = power;
    motor[BackLeft] = -power;
}

void Rotate(int power)
{
	if (SensorValue[Jumper2] == 0)
	{
		power = -power;
	}
    motor[FrontLeft] = power;
    motor[FrontRight] = -power;
    motor[BackRight] = -power;
    motor[BackLeft] = power;
}

void GyroRotate (int angle)
{
	bool tryingtomove = false;
	SensorValue[Gyro] = 0;
	if (SensorValue[Jumper2] == 0)	{
		angle = -angle;
	}
	if (SensorValue[Gyro] < angle)
	{
		while (SensorValue[Gyro] < angle)
		{
			Rotate(50);
			//tryingtomove = true;
		}
	}
	else if (SensorValue[Gyro] > angle)
	{
		while (SensorValue[Gyro] > angle)
		{
			Rotate(-50);
			//tryingtomove = true;
		}
	}
	Rotate(0);
	//tryingtomove = false;
}

void Claw(int power)
{
    motor[CrayonIntake] = power;
}

void Lift(int power)
{
    motor[LeftLift1] = power;
    motor[LeftLift2] = power;
    motor[RightLift1] = power;
    motor[RightLift2] = power;
}
